<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Homework 1 Report</title>
    <style>
      body {
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande",
          "Lucida Sans";
        line-height: 1.6;
        margin-left: 20%;
        margin-right: 20%;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        color: #333;
      }

      section {
        margin-bottom: 20px;
      }

      h2 {
        border-bottom: 2px solid #333;
        padding-bottom: 5px;
      }

      h3 {
        margin-bottom: 2px;
      }
      ul {
        list-style-type: none;
        padding: 0;
      }

      li {
        margin-bottom: 10px;
      }
      a:link {
        color: purple;
        background-color: transparent;
        text-decoration: none;
      }

      a:visited {
        color: purple;
        background-color: transparent;
        text-decoration: none;
      }

      a:hover {
        color: #0abab5;
        background-color: transparent;
        text-decoration: underline;
      }

      a:active {
        color: #10098f;
        background-color: transparent;
        text-decoration: underline;
      }
      *::first-letter {
        text-transform: uppercase;
      }
      ul {
        list-style-type: disc; /* Default is disc */
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Report for Homework 1: Rasterizer</h1>
      <p>Date: Feb 11, 2024</p>
      <p>
        Group Member:
        <a href="https://github.com/whydarren-6uom">Darren Wang</a>,
        <a href="https://github.com/Sunnyweather1314">Jiayi Xu</a>
      </p>
    </header>

    <section id="overview">
      <h2>Homework Description</h2>
      <p>
        In this assignment, you will implement a simple rasterizer, including
        features like drawing triangles, supersampling, hierarchical transforms,
        and texture mapping with antialiasing.
      </p>
    </section>

    <section id="task1">
      <h2>Task 1: Drawing Single-Color Triangles (20 pts)</h2>
      <div
        style="
          display: flex;
          justify-content: center;
          align-items: center;
          flex-direction: column;
        "
      >
        <img src="Task1.png" style="width: 70%" />
        <p style="text-align: center; font-size: medium">basic/test4.svg</p>
      </div>
      <h3>Solution Walk Though</h3>
      <p>
        In this task, we implemented a naive algorithm for pixel sampling within
        triangle shapes. Initially, we utilized the provided helper function
        <span style="background-color: rgb(220, 220, 217)">rasterize_line</span>
        to draw the edges of the triangles. Subsequently, we determined the
        position of the smallest bounding rectangle around the triangle. We then
        iterated through every pixel within that rectangle, applying the
        Barycentric Coordinate method to ascertain whether each pixel resides
        inside the triangle and should be colored.
      </p>
      <h3>Optimization</h3>
      <div
        style="
          display: flex;
          justify-content: center;
          align-items: center;
          height: 40%;
          margin: 0px;
        "
      >
        <div
          style="
            border: 2px solid black;
            display: inline-block;
            margin-top: 10px;
            position: relative;
            width: 200px;
            height: 200px;
            transform: scale(1.5);
          "
        >
          <div
            style="
              position: absolute;
              bottom: 0;
              left: 50%;
              transform: translateX(-50%);
              width: 0;
              border-left: 100px solid transparent;
              border-right: 100px solid transparent;
              border-bottom: 200px solid black; /* Adjusted to match the height of the bounding rectangle */
            "
          ></div>
          <div
            style="
              position: absolute;
              bottom: 50%;
              left: 15px;
              width: 5px;
              height: 5px;
              background-color: red;
              border-radius: 50%;
            "
          ></div>
          <div
            style="
              position: absolute;
              bottom: 50%;
              right: 15px;
              width: 5px;
              height: 5px;
              background-color: red;
              border-radius: 50%;
            "
          ></div>
          <div style="position: absolute; bottom: 55%; left: 15px">A</div>
          <div style="position: absolute; bottom: 55%; right: 15px">B</div>
        </div>
      </div>
      <p>
        One way that we did to optimize the algorithm is to detect when we are
        out of the triangle for the second time.
      </p>
      <p>
        To be specific, we used the fact that when we iterating through the
        circumscribed rectangle of the triangle, we will be out of the triangle
        for at most twice. See point A and B in the graph above.
        <span style="background-color: rgb(220, 220, 217)">Point A</span>
        represents the first time we are out of the triangle, and
        <span style="background-color: rgb(220, 220, 217)">Point B</span>
        represents the second time we are out of the triangle. As we can see, we
        are not going to be in the triangle for another time.
      </p>
      <p>
        Therefore, we can stop the iteration when we are out of the triangle for
        the second time. This will make sure that we don't need to iterate
        through the whole circumscribed rectangle of the triangle.
      </p>
      <h3>Usage</h3>
      <p>
        Barycentric Coordinates are commonly used in computer graphics,
        particularly in rendering techniques such as triangle interpolation and
        texture mapping.
      </p>
    </section>

    <section id="task2">
      <h2>Task 2: Antialiasing by Supersampling (20 pts)</h2>
      <div style="display: flex; justify-content: center; align-items: center">
        <img src="Task2.png" style="width: 50%" />
      </div>
      <h3>Solution Walk Though</h3>
      <p>
        This is one of the key parts of the whole homework coding part. In this
        section, we are supersampling every one pixel of our buffer. As we can
        see in the description diagram provided on the website (shown as above),
        supersampling provides us a more precise result by checking on which
        smaller pixel is in the area and which ones are not. Therefore, we can
        combine them back to one pixel with color averaged from the smaller
        pixels. This will make sure that we have a more precise result and the
        edges of the triangle will be smoother.
      </p>
      <h3>Algorithm</h3>
      <p>
        The way we implemented it is to divide the pixel into
        <span style="background-color: rgb(220, 220, 217)">sample_rate</span>
        subpixels and then sample the color of the subpixels in
        <span style="background-color: rgb(220, 220, 217)"
          >void RasterizerImp::rasterize_triangle</span
        >
        . We also need to update our algorithm for calculating Barycentric
        Coordinates at the same time since our coordinates for
        <span style="background-color: rgb(220, 220, 217)"
          >x0, y0, x1, ...., y3</span
        >
        have changed according to our sample_rate. The rest are quite the same
        as in the previous task. We just iterate the whole rectangle and send
        the colors to the
        <span style="background-color: rgb(220, 220, 217)">sample_buffer</span>
        .
      </p>
      <p>
        We then average the color of the subpixels and assign it to the pixel in
        RasterizerImp::resolve_to_framebuffer. To average the color, we just
        simply add up the colors for every single subpixel for one original
        pixel (
        <span style="background-color: rgb(220, 220, 217)">sample_rate</span>
        subpixels in total) and then divide it by the

        <span style="background-color: rgb(220, 220, 217)">sample_rate</span>.
        We then assign the result to the pixel in the framebuffer.
      </p>
      <p>
        However, we also need to alter our
        <span style="background-color: rgb(220, 220, 217)"
          >void RasterizerImp::fill_pixel</span
        >
        function for this one since our lines and points does not need to be
        supersampled. We can simply alter this function by assigning the same
        color to all
        <span style="background-color: rgb(220, 220, 217)">sample_rate</span>
        subpixels.
      </p>
      <h3>Result</h3>
      <div style="display: flex; justify-content: center; margin-top: 15px">
        <div style="flex-direction: column">
          <img src="Task2-1.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Sample Rate = 1</p>
        </div>
        <div style="flex-direction: column">
          <img src="Task2-4.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Sample Rate = 4</p>
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-bottom: 15px">
        <div style="flex-direction: column">
          <img src="Task2-9.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Sample Rate = 9</p>
        </div>
        <div style="flex-direction: column">
          <img src="Task2-16.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Sample Rate = 16</p>
        </div>
      </div>
    </section>

    <section id="task3">
      <h2>Task 3: Transforms (10 pts)</h2>
      <div style="display: flex; justify-content: center; align-items: center">
        <img src="Task3.png" style="width: 50%" />
      </div>
      <p>
        created a cubeman in running posture by doing the following operations.
      </p>
      <ul>
        <li>
          rotate the head and torso by a certain angle to make it more natural.
        </li>
        <li>
          adjusted the angle and position of the arms and legs to add dynamic to
          the body.
        </li>
      </ul>
    </section>

    <section id="task4">
      <h2>Task 4: Barycentric Coordinate (10 pts)</h2>
      <p></p>
      <ul>
        <li></li>
        <li></li>
      </ul>
    </section>

    <section id="task5">
      <h2>Task 5: "Pixel sampling" for texture mapping (15 pts)</h2>
      <p>
        Pixel sampling involves determining the color of a pixel in an image. In
        texture mapping, I implemented it by mapping texture coordinates to
        corresponding pixels and then sample on the mipmap of level 0. Following
        are two ways to do pixel sampling:
      </p>
      <ul>
        <li>
          Nearest Neighbor Sampling: When an image is resized or transformed,
          each pixel in the new image is assigned the color value of the nearest
          pixel in the original image. This method is quick and computationally
          less intensive but can result in jagged edges and blocky artifacts,
          especially when scaling up. The way we implemented it was to take the
          float cordinates and round it to the nearest int cordinates.
        </li>
        <li>
          Bilinear Interpolation: It considers the weighted average of the four
          nearest pixels in the original image to determine the color of a pixel
          in the new image. This results in smoother transitions and better
          image quality during resizing or transformations. The way we
          implemented this was to do interpolations between two reference points
          and the current point. At first, we have four reference points
          (vertices of the pixel the current point in in). We do interpolation
          according to the graph below from the lecture.
        </li>
      </ul>
      <div style="display: flex; justify-content: center; align-items: center">
        <img src="Task5-Bilinear-Graph.png" style="width: 60%" />
      </div>
      <h3>
        Image Comparason between Nearest Neighbor Sampling Bilinear
        Interpolation
      </h3>
      <div style="display: flex; justify-content: center; margin-top: 15px">
        <div style="flex-direction: column">
          <img src="Task5-Nearest-1.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Nearest-1</p>
        </div>
        <div style="flex-direction: column">
          <img src="Task5-Nearest-16.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Nearest-16</p>
        </div>
      </div>
      <div style="display: flex; justify-content: center; margin-bottom: 15px">
        <div style="flex-direction: column">
          <img src="Task5-Bilinear-1.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Bilinear-1</p>
        </div>
        <div style="flex-direction: column">
          <img src="Task5-Bilinear-16.png" style="width: 100%" />
          <p style="text-align: center; font-size: medium">Bilinear-16</p>
        </div>
      </div>
      <p>From the above imagines, we can see the order of smoothness is:</p>
      <p>Nearest-1 < Nearest-16 < Bilinear-1 < Bilinear-16</p>
      <p>
        The differences between Nearest Neighbor Sampling and Bilinear
        Interpolation becomes noticeable when there are significant variations
        in texture magnification or reduction. This is because that Nearest
        Neighbor Sampling assigns the nearest pixel color, causing blockiness
        during size changes. While Bilinear Interpolation blends neighboring
        pixels, offering smoother transitions.
      </p>

      <p></p>
    </section>

    <section id="task6">
      <h2>
        Task 6: "Level sampling" with mipmaps for texture mapping (25 pts)
      </h2>
      <p>
        Level sampling is a technique used in computer graphics for efficient
        rendering. It involves sampling pixels at different levels of detail,
        starting with a coarse level and gradually refining to finer levels.
        Level sampling relies on the principle that people don't perceive
        resolution changes over distances. It optimizes performance by adjusting
        image details based on viewing distance, saving computational resources.
      </p>
      <p>
        The way that we implemented level sampling invloves functions: get
        level, sample and rasterize_textured_triangle.
      </p>
      <ul>
        <li>
          float Texture::get_level: We determine the level of mipmap of a
          certain point by using the derivative vectors passed into the
          function.
        </li>
        <div
          style="display: flex; justify-content: center; align-items: center"
        >
          <img src="Task6-Level.png" style="width: 60%" />
        </div>
        <li>
          Color Texture::sample: Use the helper function get_level that we
          implemented before to get a certain level of mipmap. And then decide
          which combination of sampling methods that we want to use according to
          field sp->lsm and sp->psm. Collect the sampled colour and return it to
          the rasterize_textured_triangle function.
        </li>
        <li>
          <span style="background-color: rgb(220, 220, 217)"
            >void RasterizerImp::rasterize_textured_triangle</span
          >: We reused a lot of the codes from task 2. The difference is that we
          did three Barycentric interpolations separately on point(x, y), (x+1,
          y), (x, y+1) and
        </li>
      </ul>
    </section>
  </body>
</html>
